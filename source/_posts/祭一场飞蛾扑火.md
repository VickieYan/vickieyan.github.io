---
title: 夕顔 | 祭一场飞蛾扑火
date: 2018-04-09 16:58:02
tags:
---

大概从高中毕业以后，已经很久没有如此执着的想要去完成一件事了。默默的悄无声息的想要去完成一件事。

幻想过无数种场景，自己披襟斩棘最终站在那栋记忆中的大楼下，迎面走过来那人会是怎样的表情呢。

幻想终究是幻想，说到底自己一开始也从没有想过能够真正实现，可是就是不知道从哪一天开始脑子里就开始冒出这个疯狂的念头了。

会开始去网上找一些招聘信息，开始联络学长学姐，希望能得到一个内推机会，开始补自己的知识漏洞，看很多面试题，学习棘手的算法。

可是心里非常清楚，什么是以卵击石，什么是飞蛾扑火。

那天晚上的心情，我还依稀记得。

和学校里一个旧友谈起了工作。说真的，走到春招这一步，我已不在意身边的人到底去了哪个公司。

日语里有一个词，叫“あいにく”，翻译成中文大概是“很不凑巧”的意思。仿佛是上帝偷看了我内心的剧本，而给我安排了一场内心的历练。

她无意提起的公司名，有意无意的触碰到了那根倒插在我内心里尖锐的刺，一阵生疼。

很不凑巧，在和她聊天前我刚好收到了笔试通知。怕什么来什么。

上海寒彻骨的夜，这繁华的城，纵横满面的泪。丑态尽展。

我真的不嫉妒，不，我是嫉妒的发疯。

第一次，那么痛恨，痛恨自己没有早点学前端，或者，那么痛恨，自己学了前端。转行这条路，走的实在太艰辛了。

那一刻，才对“少壮不努力，老大徒伤悲”这句话里藏匿着的不甘与无力，理解的如此深刻。

是真的真的很不甘心吧。

---

笔试并没有想象中难，也尽力做了，但终究是再没有面试通知了。

功力尚浅，还需要大量的学习。

真的非常希望，在下一次机会来临的时候，自己不再是此时懦弱的自己，能够勇敢的并且有足够的实力去抓住它。

以下是一些题目回溯的总结。

* 按顺序取出数字的英文字母，数字去重(涉及到公司名字 匿了)

```javascript
let str = "t1测est试23";
let nums = str.match(/\d/g);
let chars = str.match(/[A-Za-z]/g);
nums = [...new Set(nums)];
let s = "";
nums.forEach(e => (s += e));
chars.forEach(e => (s += e));
console.log(s);
```

* 对一维数组，根据 type 生成二维数组。

```javascript
let str = [
  null,
  2,
  "test",
  undefined,
  {
    type: "product",
    content: "product1"
  },
  {
    type: "product",
    content: "product2"
  },
  {
    type: "tag",
    content: "tag1"
  },
  {
    type: "product",
    content: "product3"
  },
  {
    type: "tag",
    content: "tag2"
  }
];
function groupList(list) {
  // 当输入数据不合法时，输出空数组[]
  if (Object.prototype.toString.call(list) !== "[object Array]") return [];
  // 过滤掉不合法元素
  for (let i = list.length - 1; i >= 0; i--) {
    if (list[i] == null || typeof list[i] != "object") {
      list.splice(i, 1);
    }
  }
  // 获得所有类型
  let types = [];
  for (let i = list.length - 1; i >= 0; i--) {
    types.push(list[i].type);
  }
  types = [...new Set(types)];
  let product = [],
    tag = [],
    res = [];
  for (let j = 0; j < types.length; j++) {
    let newType = [];
    for (let i = list.length - 1; i >= 0; i--) {
      if (list[i].type == types[j]) {
        newType.unshift(list[i].content);
      }
    }
    res.push(newType);
  }
  let res2 = [];
  for (let j = types.length - 1; j >= 0; j--) {
    let tmp = { type: types[j], content: res[j] };
    res2.push(tmp);
  }
  return res2;
}
const data = str;
const result = groupList(data);
console.log(JSON.stringify(result));
```

* 实现类似迭代方法中的 map()方法

```javascript
function map(data, fn) {
  let res;
  if (Object.prototype.toString.call(data) === "[object Array]") {
    res = [];
    data.forEach(function(v, i, arr) {
      res.push(fn(v, i, arr));
    });
    return res;
  } else if (Object.prototype.toString.call(data) === "[object Object]") {
    res = {};
    for (let key in data) {
      res[key] = fn(data[key], key, data);
    }
    return res;
  }
  return null;
}
```
