---
title: 夕顔 | 就算是痴人说梦那又怎样
date: 2018-04-17 15:04:32
tags:
---

<center><h1>HTML</h1></center>

## 元素分类

* 行内元素(7)：a b(加粗) span img input selcet strong
* 块级元素(9)：div ul ol li dl dt dd h1 p
* 空元素(6)：br hr(直线) img input link meta

## link 和 @import 的区别

* 加载顺序（link 同时加载 @import 等页面加载完再加载）
* 分类不同（link 是 XHTML 标签，除 CSS 还可加载其他文件 @import 由 css 提供，只能加载 css）
* 兼容性（@import IE5 以上）

## HTML5 新特性

[HTML5新特性浅谈](http://www.ganecheng.tech/blog/52819118.html)

* 语义新特性（结构元素：article、footer、header、nav、section；表单控件：calendar、date、time、email、url、search;）
* 本地存储特性
* 设备访问特性
* 连接特性（WebSocket）
* 网络多媒体特性（Audio、Video）
*  三维、图形及特效特性（SVG、Canvas、WebGL）
* 性能与集成特性（WebWorkers）

## HTML5 离线缓存

Manifest文件组成：

* CACHE（必须 需要缓存的文件）
* FALLBACK（可选 后备页面）

### 如何更新缓存？

给manifest添加或删除文件，都可更新缓存。

```
window.applicationCache.update();
```

<center><h1>CSS</h1></center>

## 盒模型



![](https://img-blog.csdn.net/20140725102923126?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3pxbmxz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

## CSS选择器

1. id选择器
2. 类选择器
3. 标签选择器
4. 相邻选择器
5. 子选择器
6. 后代选择器
7. 通配符选择器
8. 属性选择器
9. 伪类选择器

### 选择器权重

内联样式表（标签内部）> 嵌入样式表（当前文件中）> 外部样式表（外部文件中）。
  !important >  id > class > tag
  !important 比 内联优先级高

## CSS3 新特性

[深入了解 CSS3 新特性](https://www.ibm.com/developerworks/cn/web/1202_zhouxiang_css3/index.html)

### CSS3 选择器

```
p:first-of-type	选择属于其父元素的首个 <p> 元素的每个 <p> 元素。
p:last-of-type	选择属于其父元素的最后 <p> 元素的每个 <p> 元素。
p:only-of-type	选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。
p:only-child		选择属于其父元素的唯一子元素的每个 <p> 元素。
p:nth-child(2)	选择属于其父元素的第二个子元素的每个 <p> 元素。

::after			在元素之前添加内容,也可以用来做清除浮动。
::before			在元素之后添加内容
:enabled  		
:disabled 		控制表单控件的禁用状态。
:checked        单选框或复选框被选中。
```

## DIV 居中

```
 div{
 	width:200px;
 	margin:0 auto;
  }
```

```
 div {
 	position: absolute;
 	width: 300px;
 	height: 300px;
 	margin: auto;
 	top: 0;
 	left: 0;
 	bottom: 0;
 	right: 0;
 }
```

```
 div {
 	position: relative;		/* 相对定位或绝对定位均可 */
 	width:500px;
 	height:300px;
 	top: 50%;
 	left: 50%;
 	margin: -150px 0 0 -250px;     	/* 外边距为自身宽高的一半 */
  }
```

```
 div {
 	position: absolute;		/* 相对定位或绝对定位均可 */
 	width:500px;
 	height:300px;
 	top: 50%;
 	left: 50%;
 	transform: translate(-50%, -50%);
 }
```

```
 .container {
 	display: flex;
 	align-items: center; 		/* 垂直居中 */
 	justify-content: center;	/* 水平居中 */

 }
 .container div {
 	width: 100px;
 	height: 100px;
 }  
```

## display有哪些值

[CSS display 属性](http://www.w3school.com.cn/css/pr_class_display.asp)



| 值                 | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| none               | 此元素不会被显示。                                           |
| block              | 此元素将显示为块级元素，此元素前后会带有换行符。             |
| inline             | 默认。此元素会被显示为内联元素，元素前后没有换行符。         |
| inline-block       | 行内块元素。（CSS2.1 新增的值）                              |
| list-item          | 此元素会作为列表显示。                                       |
| run-in             | 此元素会根据上下文作为块级元素或内联元素显示。               |
| table              | 此元素会作为块级表格来显示（类似 <table>），表格前后带有换行符。 |
| inline-table       | 此元素会作为内联表格来显示（类似 <table>），表格前后没有换行符。 |
| table-row-group    | 此元素会作为一个或多个行的分组来显示（类似 <tbody>）。       |
| table-header-group | 此元素会作为一个或多个行的分组来显示（类似 <thead>）。       |
| table-footer-group | 此元素会作为一个或多个行的分组来显示（类似 <tfoot>）。       |
| table-row          | 此元素会作为一个表格行显示（类似 <tr>）。                    |
| table-column-group | 此元素会作为一个或多个列的分组来显示（类似 <colgroup>）。    |
| table-column       | 此元素会作为一个单元格列显示（类似 <col>）                   |
| table-cell         | 此元素会作为一个表格单元格显示（类似 <td> 和 <th>）          |
| table-caption      | 此元素会作为一个表格标题显示（类似 <caption>）               |
| inherit            | 规定应该从父元素继承 display 属性的值。                      |

### inline、inline-block、block的区别

inline

1. 不能设置高宽

2. margin只对横向生效，纵向无效

3. 关于padding比较迷，下面来细细说明一下

   ![code](http://m.qpic.cn/psb?/V10ZHE9M4DB6nN/lgm0qAHFaIkFJcdfLbUg72Q6Ucg2sQMSGudl68KwpIQ!/b/dDIBAAAAAAAA&bo=QAMMAgAAAAADB28!&rf=viewer_4)

   给两个inline元素分别设置了100px的padding，我以为会出现上下padding不生效，左右padding生效的效果，而结果比较意外。

   ![preview](http://m.qpic.cn/psb?/V10ZHE9M4DB6nN/xpNm2ZGe0ERiGhbk34hA*wKu*FgWtzlYSlC.nm.O.*8!/b/dDEBAAAAAAAA&bo=zgMkAQAAAAADB8o!&rf=viewer_4)

   [inline element 與 padding 的二三事](http://muki.tw/tech/inline-element-width-padding/)

   读完这篇文章你会发现，其实对于inline元素来说，padding四个方向的值都是生效的，只是他不会向块级元素一样影响其他元素的布局，而是产生一种堆叠效果。

   ![inline padding](http://m.qpic.cn/psb?/V10ZHE9M4DB6nN/KQvmm8T9un1jYnAgihtvX4Q62Pks.gBRQqJmArtU*0c!/b/dDMBAAAAAAAA&bo=fgI6BQAAAAADF3E!&rf=viewer_4)

   Inline-block:

   1. 可以设置高宽
   2. margin和padding四个方向均生效
   3. 默认不换行

## 弹性盒模型

[Flex 布局教程：语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)

[Flex 布局教程：实例篇](http://www.ruanyifeng.com/blog/2015/07/flex-examples.html)

## 常见布局

### 多列等高布局

padding补偿法

```css
在需要等高布局等每个元素都设置 很大的正的padding-bottom, 很大的负的margin-bottom;  
padding-bottom: 2000px;
margin-bottom: -2000px;
```

## BFC(块级格式化上下文)

[CSS之BFC详解](http://www.html-js.com/article/1866)

### BFC应用场景

在讲解BFC之前我们首先看一下BFC有哪些应用场景

1. 垂直方向上margin叠加问题
2. overflow:hidden 清除浮动

### BFC特性

1. 同一个BFC的两个相邻Box的margin会发生叠加
2. 计算BFC的高度时，浮动元素也参与计算

### BFC触发条件

1. float 除了none以外的值
2. overflow 除了visible 以外的值（hidden，auto，scroll ）
3. display (table-cell，table-caption，inline-block, flex, inline-flex)
4. position值为（absolute，fixed）
5. fieldset元素

<center><h1>JavaScript</h1></center>



<center><h1>Web 综合</h1></center>

## 常见的浏览器内核

* Trident： IE
* Gecko: FireFox
* Presto: Opera
* Webkit: Safari, Chrome

## 介绍一下你对浏览器内核的理解？

[从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理](https://juejin.im/post/5a6547d0f265da3e283a1df7)

### 进程和线程的区别

* 进程是 cpu 资源分配的最小单位
* 线程是 cpu 调度的最小单位

### 浏览器是多进程的

![浏览器](http://m.qpic.cn/psb?/V10ZHE9M4DB6nN/KGJ*ub*P0OlFT9iNDSWPkqkDJEVOLTpcHwf40WPFxI8!/b/dDIBAAAAAAAA&bo=WASaAlgEmgIDByI!&rf=viewer_4)

浏览器有以下几个进程：

1.  Browser 进程（主程）

* 负责浏览器界面显示，与用户交互。如前进，后退等
* 负责各个页面的管理，创建和销毁其他进程
* 将 Renderer 进程得到的内存中的 Bitmap，绘制到用户界面上
* 网络资源的管理，下载等

2.  第三方插件进程
3.  GPU 进程（3D 绘制）
4.  浏览器渲染进程 = 浏览器内核（每个 Tab 一个进程，多个空白页自动合并成一个进程。用于页面渲染、脚本运行、事件处理等）

敲黑板，划重点，**浏览器的渲染进程是多线程的**。那么我们来看看它包括哪些线程。

1.  GUI 渲染线程（Graphical User Interface）

* 负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。
* 注意，**GUI 渲染线程与 JS 引擎线程是互斥的**，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。

2.  JS 引擎线程

* 也称为 JS 内核，负责处理 Javascript 脚本程序。

3.  事件触发线程
4.  定时触发器线程
5.  异步 http 请求线程



## 从打开浏览器到页面渲染的过程

[从输入一个 url 后到页面加载完成都发生了什么](https://blog.csdn.net/crystal6918/article/details/55190555)

[从输入 url 到页面加载发生了什么 --Jason 哥](http://zining.me/2017/07/13/how-it-works-when-enter-a-url/)

![渲染过程](http://m.qpic.cn/psb?/V10ZHE9M4DB6nN/aNXyz9JQ.4E.VXpNQOCpr5hhZbPuG0unGonIzR8a8uw!/b/dJEAAAAAAAAA&bo=VAY4BL4HKQUDCdc!&rf=viewer_4)

![DNS查询过程](http://m.qpic.cn/psb?/V10ZHE9M4DB6nN/4WWkRFfOasiVJRaGA0d6o8lLqQAoCSg0kCFYlcd2c9c!/b/dDMBAAAAAAAA&bo=pAQBA6QEAQMRBzA!&rf=viewer_4)

1.  用户输入 URL
1.  判断是否命中强缓存，若命中，直接返回缓存资源。
1.  开始 DNS 解析，详细过程参考[从输入一个 url 后到页面加载完成都发生了什么](https://blog.csdn.net/crystal6918/article/details/55190555)
1.  建立 TCP 连接（三次握手）
1.  TCP 建立完成后发送 HTTP 请求
1.  服务器接受请求并解析，如果头部有缓存相关信息如 if-none-match 与 if-modified-since，则验证缓存是否有效，若有效则返回 304
1.  服务器将响应报文通过 TCP 连接发送回浏览器
1.  浏览器接收响应，并关闭 TCP 连接（四次挥手）
1.  浏览器检查状态码并进行对应操作
1.  Browser 进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过 RendererHost 接口传递给 Render 进程
1.  Renderer 进程的 Renderer 接口收到消息，简单解释后，交给渲染线程，然后开始渲染
1.  解析 html 建立 dom 树
1.  解析 css 构建 render 树（将 CSS 代码解析成树形的数据结构，然后结合 DOM 合并成 render 树）
1.  布局 render 树（Layout/reflow），负责各元素尺寸、位置的计算
1.  绘制 render 树（paint），绘制页面像素信息
1.  浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（composite），显示在屏幕上。



## TCP 三次握手和四次挥手

[图解 TCP 三次握手与四次分手](https://juejin.im/post/5a7835a46fb9a063606eb801)

[TCP 连接的建立和释放](https://blog.csdn.net/ns_code/article/details/29382883)

首先我们来看看 TCP 的报文里都有哪些字段。

[TCP 报文](http://m.qpic.cn/psb?/V10ZHE9M4DB6nN/SiMINktkHgw*QavvhLkHckJaSDF9nRtWjZly9wYgUIA!/b/dGoBAAAAAAAA&bo=7wLMAe8CzAEDCSw!&rf=viewer_4)

下面我们来分别解释一下在连接中我们使用到的字段分别代表什么意思：

* SYN: 同步序号(synchronous)，用来发起一个连接。当 SYN=1 而 ACK=0 时，表明这是一个连接请求报文段，若对方同意建立连接，则应在响应的报文段中使 SYN=1 和 ACK=1。
* ACK: 确认字符(acknowledgement)，仅当 ACK=1 时确认号字段才有效，当 ACK=0 时，确认号无效。TCP 规定，在连接建立后所有的传送报文段都必须把 ACK 置 1。

### 三次握手

![三次握手](http://m.qpic.cn/psb?/V10ZHE9M4DB6nN/kW1TdTsjqlaKqH0nsti5RHwl1ovZhK6vFK4Ys.SC.0I!/b/dEUBAAAAAAAA&bo=9AOzAvQDswIDCSw!&rf=viewer_4)

* 第一次握手：客户端的 TCP 进程首先创建传输控制模块 TCB，然后向服务端发出连接请求报文段，该报文段首部中的 **SYN=1，ACK=0**，同时选择一个初始序号 **seq=i**。TCP 规定，SYN=1 的报文段不能携带数据，但要消耗掉一个序号。这时，TCP 客户进程进入 **SYN—SENT（同步已发送）状态**，这是 TCP 连接的第一次握手。

* 第二次握手：服务端收到客户端发来的请求报文后，如果同意建立连接，则向客户端发送确认。确认报文中的 **SYN=1，ACK=1**，确认号 ack=i+1，同时为自己选择一个初始序号 **seq=j**。同样该报文段也是 SYN=1 的报文段，不能携带数据，但同样要消耗掉一个序号。这时，TCP 服务端进入 **SYN—RCVD（同步收到）状态**，这是 TCP 连接的第二次握手。

* 第三次握手：TCP 客户端进程收到服务端进程的确认后，还要向服务端给出确认。确认报文段的 **ACK=1**，确认号 **ack=j+1**，而自己的序号为 **seq=i+1**。TCP 的标准规定，ACK 报文段可以携带数据，但如果不携带数据则不消耗序号，因此，如果不携带数据，则下一个报文段的序号仍为 seq=i+1。这时，TCP 连接已经建立，客户端进入 **ESTABLISHED（已建立连接）状态**。这是 TCP 连接的第三次握手，可以看出第三次握手客户端已经可以发送携带数据的报文段了。

知乎上一生动的段子：

> * 第一次握手：约吗
> * 第二次握手：约
> * 第三次握手：那我出发了

### 四次挥手

![四次挥手](https://user-gold-cdn.xitu.io/2018/2/5/1616591831ac99e0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 浏览器缓存

[浏览器缓存知识小结及应用](https://www.cnblogs.com/lyzg/p/5125934.html)

### 强缓存

命中缓存后返回 200。

字段：

* expires
* cache-control

禁止缓存：Cache-Control: no-cache, no-store, must-revalidate

缓存静态资源 Cache-Control:public, max-age=31536000

* pragma

建议只在需要兼容 HTTP/1.0 客户端的场合下应用 Pragma 首部。

![强缓存](http://m.qpic.cn/psb?/V10ZHE9M4DB6nN/an8Hh1QW*YwmQ*rdu3r7U9YXzbG5kfG*4aCTrz3G60E!/b/dEIBAAAAAAAA&bo=LAPpAQAAAAADB.U!&rf=viewer_4)

要注意，强缓存通常都是针对静态资源使用，动态资源需要慎用。

这里回溯一下之前项目中碰到的缓存问题。在之前的项目中发送 Ajax 请求时，我们通过了在请求的 URL 后面添加时间戳破缓存，这里解释一下原理。

浏览器缓存是基于 url 进行缓存的，如果页面允许缓存，则在一定时间内（缓存时效时间前）再次访问相同的 URL，浏览器就不会再次发送请求到服务器端，而是直接从缓存中获取指定资源。

```js
axios.get(`/user/check?timestamp=${new Date().getTime()}`);
```

关于缓存更新请看这里：[大公司里怎样开发和部署前端代码？](https://www.zhihu.com/question/20790576)

### 协商缓存

命中缓存后返回 304。

字段：

* Last-Modified
* If-Modified-Since

如果 Last-Modified 比 If-Modified-Since 晚，就从服务器端拉取数据

* ETag
* If-None-Match

如果 If-None-Match 和 Etag 不一致时，从服务器端拉取数据

![协商缓存](http://m.qpic.cn/psb?/V10ZHE9M4DB6nN/RvrO8QgnWiz*cp5*cj9WG.euzrkilfsUaLzbGtJTNj8!/b/dPIAAAAAAAAA&bo=BANYAgAAAAADB38!&rf=viewer_4)

### 浏览器行为对缓存的影响

1.  当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；

2.  当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存；



## load 事件和 DOMContentLoaded 事件的先后

* 当 DOMContentLoaded 事件触发时，仅当 DOM 加载完成，不包括样式表，图片。 (譬如如果有 async 加载的脚本就不一定完成)

* 当 onload 事件触发时，页面上所有的 DOM，样式表，脚本，图片都已经加载完成了。 （渲染完毕了）

DOMContentLoaded -> load

