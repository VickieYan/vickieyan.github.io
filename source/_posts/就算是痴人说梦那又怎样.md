---
title: 夕顔 | 就算是痴人说梦那又怎样
date: 2018-04-17 15:04:32
tags:
---

<center><h1>HTML</h1></center>

## 元素分类

* 行内元素(7)：a b(加粗) span img input selcet strong
* 块级元素(9)：div ul ol li dl dt dd h1 p
* 空元素(6)：br hr(直线) img input link meta

---

## link 和 @import 的区别

* 加载顺序（link 同时加载 @import 等页面加载完再加载）
* 分类不同（link 是 XHTML 标签，除 CSS 还可加载其他文件 @import 由 css 提供，只能加载 css）
* 兼容性（@import IE5 以上）

---

<center><h1>Web 综合</h1></center>

## 介绍一下你对浏览器内核的理解？

[从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理](https://juejin.im/post/5a6547d0f265da3e283a1df7)

### 进程和线程的区别

* 进程是 cpu 资源分配的最小单位
* 线程是 cpu 调度的最小单位

### 浏览器是多进程的

![浏览器](http://m.qpic.cn/psb?/V10ZHE9M4DB6nN/KGJ*ub*P0OlFT9iNDSWPkqkDJEVOLTpcHwf40WPFxI8!/b/dDIBAAAAAAAA&bo=WASaAlgEmgIDByI!&rf=viewer_4)

浏览器有以下几个进程：

1.  Browser 进程（主程）

* 负责浏览器界面显示，与用户交互。如前进，后退等
* 负责各个页面的管理，创建和销毁其他进程
* 将 Renderer 进程得到的内存中的 Bitmap，绘制到用户界面上
* 网络资源的管理，下载等

2.  第三方插件进程
3.  GPU 进程（3D 绘制）
4.  浏览器渲染进程 = 浏览器内核（每个 Tab 一个进程，多个空白页自动合并成一个进程。用于页面渲染、脚本运行、事件处理等）

敲黑板，划重点，**浏览器的渲染进程是多线程的**。那么我们来看看它包括哪些线程。

1.  GUI 渲染线程（Graphical User Interface）

* 负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。
* 注意，**GUI 渲染线程与 JS 引擎线程是互斥的**，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。

2.  JS 引擎线程

* 也称为 JS 内核，负责处理 Javascript 脚本程序。

3.  事件触发线程
4.  定时触发器线程
5.  异步 http 请求线程

---

## 从打开浏览器到页面渲染的过程

[从输入一个 url 后到页面加载完成都发生了什么](https://blog.csdn.net/crystal6918/article/details/55190555)

[从输入 url 到页面加载发生了什么 --Jason 哥](http://zining.me/2017/07/13/how-it-works-when-enter-a-url/)

![渲染过程](http://m.qpic.cn/psb?/V10ZHE9M4DB6nN/aNXyz9JQ.4E.VXpNQOCpr5hhZbPuG0unGonIzR8a8uw!/b/dJEAAAAAAAAA&bo=VAY4BL4HKQUDCdc!&rf=viewer_4)

![DNS查询过程](http://m.qpic.cn/psb?/V10ZHE9M4DB6nN/4WWkRFfOasiVJRaGA0d6o8lLqQAoCSg0kCFYlcd2c9c!/b/dDMBAAAAAAAA&bo=pAQBA6QEAQMRBzA!&rf=viewer_4)

1.  用户输入 URL
1.  判断是否命中强缓存，若命中，直接返回缓存资源。
1.  开始 DNS 解析，详细过程参考[从输入一个 url 后到页面加载完成都发生了什么](https://blog.csdn.net/crystal6918/article/details/55190555)
1.  建立 TCP 连接（三次握手）
1.  TCP 建立完成后发送 HTTP 请求
1.  服务器接受请求并解析，如果头部有缓存相关信息如 if-none-match 与 if-modified-since，则验证缓存是否有效，若有效则返回 304
1.  服务器将响应报文通过 TCP 连接发送回浏览器
1.  浏览器接收响应，并关闭 TCP 连接（四次挥手）
1.  浏览器检查状态码并进行对应操作
1.  Browser 进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过 RendererHost 接口传递给 Render 进程
1.  Renderer 进程的 Renderer 接口收到消息，简单解释后，交给渲染线程，然后开始渲染
1.  解析 html 建立 dom 树
1.  解析 css 构建 render 树（将 CSS 代码解析成树形的数据结构，然后结合 DOM 合并成 render 树）
1.  布局 render 树（Layout/reflow），负责各元素尺寸、位置的计算
1.  绘制 render 树（paint），绘制页面像素信息
1.  浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（composite），显示在屏幕上。

---

## TCP 三次握手和四次挥手

[图解 TCP 三次握手与四次分手](https://juejin.im/post/5a7835a46fb9a063606eb801)

[TCP 连接的建立和释放](https://blog.csdn.net/ns_code/article/details/29382883)

首先我们来看看 TCP 的报文里都有哪些字段。

[TCP 报文](http://m.qpic.cn/psb?/V10ZHE9M4DB6nN/SiMINktkHgw*QavvhLkHckJaSDF9nRtWjZly9wYgUIA!/b/dGoBAAAAAAAA&bo=7wLMAe8CzAEDCSw!&rf=viewer_4)

下面我们来分别解释一下在连接中我们使用到的字段分别代表什么意思：

* SYN: 同步序号(synchronous)，用来发起一个连接。当 SYN=1 而 ACK=0 时，表明这是一个连接请求报文段，若对方同意建立连接，则应在响应的报文段中使 SYN=1 和 ACK=1。
* ACK: 确认字符(acknowledgement)，仅当 ACK=1 时确认号字段才有效，当 ACK=0 时，确认号无效。TCP 规定，在连接建立后所有的传送报文段都必须把 ACK 置 1。

### 三次握手

![三次握手](http://m.qpic.cn/psb?/V10ZHE9M4DB6nN/kW1TdTsjqlaKqH0nsti5RHwl1ovZhK6vFK4Ys.SC.0I!/b/dEUBAAAAAAAA&bo=9AOzAvQDswIDCSw!&rf=viewer_4)

* 第一次握手：客户端的 TCP 进程首先创建传输控制模块 TCB，然后向服务端发出连接请求报文段，该报文段首部中的 **SYN=1，ACK=0**，同时选择一个初始序号 **seq=i**。TCP 规定，SYN=1 的报文段不能携带数据，但要消耗掉一个序号。这时，TCP 客户进程进入 **SYN—SENT（同步已发送）状态**，这是 TCP 连接的第一次握手。

* 第二次握手：服务端收到客户端发来的请求报文后，如果同意建立连接，则向客户端发送确认。确认报文中的 **SYN=1，ACK=1**，确认号 ack=i+1，同时为自己选择一个初始序号 **seq=j**。同样该报文段也是 SYN=1 的报文段，不能携带数据，但同样要消耗掉一个序号。这时，TCP 服务端进入 **SYN—RCVD（同步收到）状态**，这是 TCP 连接的第二次握手。

* 第三次握手：TCP 客户端进程收到服务端进程的确认后，还要向服务端给出确认。确认报文段的 **ACK=1**，确认号 **ack=j+1**，而自己的序号为 **seq=i+1**。TCP 的标准规定，ACK 报文段可以携带数据，但如果不携带数据则不消耗序号，因此，如果不携带数据，则下一个报文段的序号仍为 seq=i+1。这时，TCP 连接已经建立，客户端进入 **ESTABLISHED（已建立连接）状态**。这是 TCP 连接的第三次握手，可以看出第三次握手客户端已经可以发送携带数据的报文段了。

知乎上一生动的段子：

> * 第一次握手：约吗
> * 第二次握手：约
> * 第三次握手：那我出发了

### 四次挥手

![四次挥手](https://user-gold-cdn.xitu.io/2018/2/5/1616591831ac99e0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 浏览器缓存

[浏览器缓存知识小结及应用](https://www.cnblogs.com/lyzg/p/5125934.html)

### 强缓存

命中缓存后返回 200。

字段：

* expires
* cache-control

禁止缓存：Cache-Control: no-cache, no-store, must-revalidate

缓存静态资源 Cache-Control:public, max-age=31536000

* pragma

建议只在需要兼容 HTTP/1.0 客户端的场合下应用 Pragma 首部。

![强缓存](http://m.qpic.cn/psb?/V10ZHE9M4DB6nN/an8Hh1QW*YwmQ*rdu3r7U9YXzbG5kfG*4aCTrz3G60E!/b/dEIBAAAAAAAA&bo=LAPpAQAAAAADB.U!&rf=viewer_4)

要注意，强缓存通常都是针对静态资源使用，动态资源需要慎用。

这里回溯一下之前项目中碰到的缓存问题。在之前的项目中发送 Ajax 请求时，我们通过了在请求的 URL 后面添加时间戳破缓存，这里解释一下原理。

浏览器缓存是基于 url 进行缓存的，如果页面允许缓存，则在一定时间内（缓存时效时间前）再次访问相同的 URL，浏览器就不会再次发送请求到服务器端，而是直接从缓存中获取指定资源。

```js
axios.get(`/user/check?timestamp=${new Date().getTime()}`);
```

关于缓存更新请看这里：[大公司里怎样开发和部署前端代码？](https://www.zhihu.com/question/20790576)

### 协商缓存

命中缓存后返回 304。

字段：

* Last-Modified
* If-Modified-Since

如果 Last-Modified 比 If-Modified-Since 晚，就从服务器端拉取数据

* ETag
* If-None-Match

如果 If-None-Match 和 Etag 不一致时，从服务器端拉取数据

![协商缓存](http://m.qpic.cn/psb?/V10ZHE9M4DB6nN/RvrO8QgnWiz*cp5*cj9WG.euzrkilfsUaLzbGtJTNj8!/b/dPIAAAAAAAAA&bo=BANYAgAAAAADB38!&rf=viewer_4)

### 浏览器行为对缓存的影响

1.  当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；

2.  当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存；

---

## load 事件和 DOMContentLoaded 事件的先后

* 当 DOMContentLoaded 事件触发时，仅当 DOM 加载完成，不包括样式表，图片。 (譬如如果有 async 加载的脚本就不一定完成)

* 当 onload 事件触发时，页面上所有的 DOM，样式表，脚本，图片都已经加载完成了。 （渲染完毕了）

DOMContentLoaded -> load

---
